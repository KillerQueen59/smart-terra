{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 61, "column": 0}, "map": {"version":3,"sources":["file:///Users/fauzanramadhan/Ojan/smart-terra/src/utils/db.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-namespace */\nimport { PrismaClient } from \"@prisma/client\";\n\ndeclare global {\n  namespace NodeJS {\n    interface Global {\n      prisma?: PrismaClient;\n    }\n  }\n}\n\ndeclare const global: NodeJS.Global & typeof globalThis;\n\nlet prisma: PrismaClient;\n\nif (process.env.NODE_ENV === \"production\") {\n  prisma = new PrismaClient();\n} else {\n  if (!global.prisma) {\n    global.prisma = new PrismaClient();\n  }\n  prisma = global.prisma;\n}\n\nexport default prisma;\n"],"names":[],"mappings":"AAAA,kDAAkD;;;;AAClD;;AAYA,IAAI;AAEJ;;KAEO;IACL,IAAI,CAAC,yDAAO,MAAM,EAAE;QAClB,yDAAO,MAAM,GAAG,IAAI,6IAAY;IAClC;IACA,SAAS,yDAAO,MAAM;AACxB;uCAEe","debugId":null}},
    {"offset": {"line": 81, "column": 0}, "map": {"version":3,"sources":["file:///Users/fauzanramadhan/Ojan/smart-terra/src/utils/dashboardAggregation.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n// src/utils/dashboardAggregation.ts\nimport prisma from \"@/utils/db\";\n\nexport interface DashboardAggregationResult {\n  ptId: string;\n  ptName: string;\n  kebunId: string;\n  kebunName: string;\n  deviceType: string; // \"AWL\" or \"AWS\"\n  rusak: number;\n  idle: number;\n  active: number;\n  alert: number;\n}\n\nexport interface DashboardFilters {\n  pt?: string;\n  kebun?: string;\n  deviceType?: string; // \"AWL\" or \"AWS\"\n}\n\n// Function to recalculate and update dashboard aggregations\nexport async function updateDashboardAggregations() {\n  try {\n    // Get all PT-Kebun combinations\n    const kebuns = await prisma.kebun.findMany({\n      include: {\n        pt: true,\n      },\n    });\n\n    for (const kebun of kebuns) {\n      // Count AWS devices by status\n      const awsStats = await prisma.alatAWS.groupBy({\n        by: [\"status\"],\n        where: {\n          kebunId: kebun.id,\n        },\n        _count: {\n          status: true,\n        },\n      });\n\n      // Count AWL devices by status\n      const awlStats = await prisma.alatAWL.groupBy({\n        by: [\"status\"],\n        where: {\n          kebunId: kebun.id,\n        },\n        _count: {\n          status: true,\n        },\n      });\n\n      // Calculate AWL totals\n      const awlStatusCounts = { rusak: 0, idle: 0, active: 0, alert: 0 };\n      awlStats.forEach((stat) => {\n        if (stat.status in awlStatusCounts) {\n          awlStatusCounts[stat.status as keyof typeof awlStatusCounts] +=\n            stat._count.status;\n        }\n      });\n\n      // Calculate AWS totals\n      const awsStatusCounts = { rusak: 0, idle: 0, active: 0, alert: 0 };\n      awsStats.forEach((stat) => {\n        if (stat.status in awsStatusCounts) {\n          awsStatusCounts[stat.status as keyof typeof awsStatusCounts] +=\n            stat._count.status;\n        }\n      });\n\n      // Update or create AWL dashboard record\n      await prisma.alatDashboard.upsert({\n        where: {\n          ptId_kebunId_deviceType: {\n            ptId: kebun.ptId,\n            kebunId: kebun.id,\n            deviceType: \"AWL\",\n          },\n        },\n        update: {\n          ...awlStatusCounts,\n        },\n        create: {\n          ptId: kebun.ptId,\n          kebunId: kebun.id,\n          deviceType: \"AWL\",\n          ...awlStatusCounts,\n        },\n      });\n\n      // Update or create AWS dashboard record\n      await prisma.alatDashboard.upsert({\n        where: {\n          ptId_kebunId_deviceType: {\n            ptId: kebun.ptId,\n            kebunId: kebun.id,\n            deviceType: \"AWS\",\n          },\n        },\n        update: {\n          ...awsStatusCounts,\n        },\n        create: {\n          ptId: kebun.ptId,\n          kebunId: kebun.id,\n          deviceType: \"AWS\",\n          ...awsStatusCounts,\n        },\n      });\n    }\n\n    return true;\n  } catch (error) {\n    console.error(\"Error updating dashboard aggregations:\", error);\n    return false;\n  }\n}\n\n// Function to get dashboard data with filtering support\nexport async function getDashboardData(\n  filters: DashboardFilters = {}\n): Promise<DashboardAggregationResult[]> {\n  try {\n    // Build where clause for filtering\n    const whereClause: any = {};\n\n    // Filter by PT name\n    if (filters.pt) {\n      whereClause.pt = {\n        name: filters.pt,\n      };\n    }\n\n    // Filter by Kebun name\n    if (filters.kebun) {\n      whereClause.kebun = {\n        name: filters.kebun,\n      };\n    }\n\n    // Filter by device type\n    if (filters.deviceType) {\n      whereClause.deviceType = filters.deviceType;\n    }\n\n    const dashboardData = await prisma.alatDashboard.findMany({\n      where: whereClause,\n      include: {\n        pt: true,\n        kebun: true,\n      },\n      orderBy: [\n        { deviceType: \"asc\" }, // AWL first, then AWS\n        { pt: { name: \"asc\" } },\n        { kebun: { name: \"asc\" } },\n      ],\n    });\n\n    return dashboardData.map((item) => ({\n      ptId: item.ptId,\n      ptName: item.pt.name,\n      kebunId: item.kebunId,\n      kebunName: item.kebun.name,\n      deviceType: item.deviceType,\n      rusak: item.rusak,\n      idle: item.idle,\n      active: item.active,\n      alert: item.alert,\n    }));\n  } catch (error) {\n    console.error(\"Error fetching dashboard data:\", error);\n    return [];\n  }\n}\n\n// Function to get AWL data specifically\nexport async function getAWLDashboardData(\n  filters: Omit<DashboardFilters, \"deviceType\"> = {}\n): Promise<DashboardAggregationResult[]> {\n  return getDashboardData({ ...filters, deviceType: \"AWL\" });\n}\n\n// Function to get AWS data specifically\nexport async function getAWSDashboardData(\n  filters: Omit<DashboardFilters, \"deviceType\"> = {}\n): Promise<DashboardAggregationResult[]> {\n  return getDashboardData({ ...filters, deviceType: \"AWS\" });\n}\n\n// Function to get all PT data (unchanged)\nexport async function getPtData() {\n  try {\n    const pts = await prisma.pT.findMany({\n      orderBy: {\n        name: \"asc\",\n      },\n    });\n\n    return pts.map((pt) => ({\n      id: pt.id,\n      name: pt.name,\n    }));\n  } catch (error) {\n    console.error(\"Error fetching PT data:\", error);\n    return [];\n  }\n}\n\n// Function to get kebun data with optional PT filtering (unchanged)\nexport async function getKebunData(ptFilter?: string) {\n  try {\n    const whereClause: any = {};\n\n    // Filter kebuns by PT if provided\n    if (ptFilter) {\n      whereClause.pt = {\n        name: ptFilter,\n      };\n    }\n\n    const kebuns = await prisma.kebun.findMany({\n      where: whereClause,\n      include: {\n        pt: true,\n      },\n      orderBy: {\n        name: \"asc\",\n      },\n    });\n\n    return kebuns.map((kebun) => ({\n      id: kebun.id,\n      name: kebun.name,\n      ptId: kebun.ptId,\n      ptName: kebun.pt.name,\n    }));\n  } catch (error) {\n    console.error(\"Error fetching Kebun data:\", error);\n    return [];\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 319, "column": 0}, "map": {"version":3,"sources":["file:///Users/fauzanramadhan/Ojan/smart-terra/src/app/api/dashboard/route.ts"],"sourcesContent":["// app/api/dashboard/route.ts\nimport { NextRequest, NextResponse } from \"next/server\";\nimport {\n  getDashboardData,\n  updateDashboardAggregations,\n} from \"@/utils/dashboardAggregation\";\n\nexport const GET = async (request: NextRequest) => {\n  try {\n    // Extract query parameters\n    const { searchParams } = new URL(request.url);\n    const pt = searchParams.get(\"pt\");\n    const kebun = searchParams.get(\"kebun\");\n    const deviceType = searchParams.get(\"deviceType\");\n\n    // Create filters object\n    const filters = {\n      ...(pt && pt !== \"\" && { pt }),\n      ...(kebun && kebun !== \"\" && { kebun }),\n      ...(deviceType && deviceType !== \"\" && { deviceType }),\n    };\n\n    console.log(\"Dashboard API filters:\", filters); // Debug log\n\n    // Pass filters to your data fetching function\n    const data = await getDashboardData(filters);\n\n    console.log(\"Dashboard API data length:\", data.length); // Debug log\n\n    return NextResponse.json({ data });\n  } catch (error) {\n    console.error(\"Error fetching dashboard data:\", error);\n    return NextResponse.json(\n      { error: \"Internal Server Error\" },\n      { status: 500 }\n    );\n  }\n};\n\nexport const POST = async () => {\n  try {\n    // Trigger dashboard aggregation recalculation\n    const success = await updateDashboardAggregations();\n\n    if (success) {\n      return NextResponse.json({\n        message: \"Dashboard aggregations updated successfully\",\n      });\n    } else {\n      return NextResponse.json(\n        { error: \"Failed to update dashboard aggregations\" },\n        { status: 500 }\n      );\n    }\n  } catch (error) {\n    console.error(\"Error updating dashboard aggregations:\", error);\n    return NextResponse.json(\n      { error: \"Internal Server Error\" },\n      { status: 500 }\n    );\n  }\n};\n"],"names":[],"mappings":"AAAA,6BAA6B;;;;;;;AAC7B;AACA;;;AAKO,MAAM,MAAM,OAAO;IACxB,IAAI;QACF,2BAA2B;QAC3B,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,KAAK,aAAa,GAAG,CAAC;QAC5B,MAAM,QAAQ,aAAa,GAAG,CAAC;QAC/B,MAAM,aAAa,aAAa,GAAG,CAAC;QAEpC,wBAAwB;QACxB,MAAM,UAAU;YACd,GAAI,MAAM,OAAO,MAAM;gBAAE;YAAG,CAAC;YAC7B,GAAI,SAAS,UAAU,MAAM;gBAAE;YAAM,CAAC;YACtC,GAAI,cAAc,eAAe,MAAM;gBAAE;YAAW,CAAC;QACvD;QAEA,QAAQ,GAAG,CAAC,0BAA0B,UAAU,YAAY;QAE5D,8CAA8C;QAC9C,MAAM,OAAO,MAAM,IAAA,0JAAgB,EAAC;QAEpC,QAAQ,GAAG,CAAC,8BAA8B,KAAK,MAAM,GAAG,YAAY;QAEpE,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE;QAAK;IAClC,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,kCAAkC;QAChD,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAwB,GACjC;YAAE,QAAQ;QAAI;IAElB;AACF;AAEO,MAAM,OAAO;IAClB,IAAI;QACF,8CAA8C;QAC9C,MAAM,UAAU,MAAM,IAAA,qKAA2B;QAEjD,IAAI,SAAS;YACX,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACvB,SAAS;YACX;QACF,OAAO;YACL,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA0C,GACnD;gBAAE,QAAQ;YAAI;QAElB;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0CAA0C;QACxD,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAwB,GACjC;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}